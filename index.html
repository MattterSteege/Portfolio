<!DOCTYPE html>
<html lang="en">
<head>
<!--    no zooming-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="ui">

        <h1 class="project-header hidden" style="width: 100%">
            [Project Name]
        </h1>

        <p class="project-description hidden">
            [Project Description]
        </p>

    </div>
    <div class="buttons">
        <button id="backButton" onclick="selectCube(0,0)">â‡½</button>
    </div>

    <div class="grid"></div>

    <!-- fix the cube, you can you the coords of the corners to alter everything (top and bottom are correct, so screen space position, turn into coords and tada-->

    <div class="cells">

    </div>

    <div class="warning-screen-to-small">
        <h1>Screen is too small</h1>
        <p>Screen is too small to display the isometric grid minimal size is 1500px wide</p>
    </div>


    <script>
            const projects = [
                { title: "Domino Day", pos: {x: 1, y: 1}, image: "images/ProjectCubes/DominoDay.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Eenzaamheidsvirus", pos: {x: 2, y: 1}, image: "images/ProjectCubes/eenzaamheidsvirus.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Create The Escape", pos: {x: 3, y: 1}, image: "images/ProjectCubes/CreateTheEscape.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Mini Project 1", pos: {x: 4, y: 1}, image: "images/ProjectCubes/Miniproject1.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Daktuinen", pos: {x: 1, y: 2}, image: "images/ProjectCubes/daktuinen.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Gouda 750 Jaar", pos: {x: 2, y: 2}, image: "images/ProjectCubes/Gouda750Jaar.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Tiny House", pos: {x: 3, y: 2}, image: "images/ProjectCubes/TinyHouse.png", desc: "Lorem Ipsum is simply dummy text..." },
                { title: "Suiker Vervanger", pos: {x: 4, y: 2}, image: "images/ProjectCubes/SuikerVervanger.png", desc: "Lorem Ipsum is simply dummy text..." }
            ];

            const cellsContainer = document.querySelector('.cells');
            const grid = document.querySelector('.grid');
            const projectHeader = document.querySelector('.project-header');
            const projectDescription = document.querySelector('.project-description');
            const backButton = document.querySelector('.buttons #backButton');

            function generateProjectsWithDelay() {
                const gridSize = parseFloat(getComputedStyle(document.body).getPropertyValue('--grid-size')) || 100;
                const gap = parseFloat(getComputedStyle(document.body).getPropertyValue('--gap')) || 10;
                let delay = 0;

                projects.forEach((project) => {
                    setTimeout(() => {
                        const cell = document.createElement('div');
                        cell.classList.add('cell', 'falling');
                        cell.style.animationDelay = `${delay}ms`;

                        // Set dataset attributes
                        cell.dataset.desc = project.desc;
                        cell.dataset.x = project.pos.x;
                        cell.dataset.y = project.pos.y;

                        // Calculate positions dynamically
                        const top = `calc(${gridSize}px * ${project.pos.y - 1} + ${gap}px * ${project.pos.y - 1})`;
                        const left = `calc(${gridSize}px * ${project.pos.x - 1} + ${gap}px * ${project.pos.x - 1})`;
                        cell.style.top = top;
                        cell.style.left = left;
                        cell.style.position = "absolute";
                        cell.style.zIndex = 1000 - (project.pos.x * 10 + project.pos.y);

                        // Add onclick event for selection
                        cell.setAttribute('onclick', `selectCube(${project.pos.x}, ${project.pos.y})`);

                        // Add image and hover cover
                        const img = document.createElement('img');
                        img.src = project.image;
                        img.alt = project.title;
                        img.height = 160;
                        img.width = 80;

                        const hoverCover = document.createElement('div');
                        hoverCover.classList.add('hover-cover');

                        cell.appendChild(img);
                        cell.appendChild(hoverCover);
                        cellsContainer.appendChild(cell);

                        // Add mouseenter event listener
                        cell.addEventListener('mouseenter', () => changeText(cell));

                        delay += 300;
                        render();
                    }, delay);
                });
            }

            function render() {
                // Render grid lines based on gap
                if (getComputedStyle(grid).getPropertyValue('--gap').trim() === '0' ||
                    getComputedStyle(grid).getPropertyValue('--gap').trim() === '0px') {
                    grid.style.backgroundImage = 'none';
                } else {
                    grid.style.backgroundImage = 'linear-gradient(0deg, var(--line-color) 1px, transparent 0), linear-gradient(90deg, var(--line-color) 1px, transparent 0)';
                }

                const cells = [];
                const cellsCount = Number(getComputedStyle(document.body).getPropertyValue('--cells'));

                // Create grid cells
                for (let x = 1; x < cellsCount + 1; x++) {
                    for (let y = 1; y < cellsCount + 1; y++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.style.top = `calc(100% - var(--grid-size) * ${cell.dataset.y} - var(--gap) * ${cell.dataset.y - 1})`;
                        cell.style.left = `calc(100% - var(--grid-size) * ${cell.dataset.x} - var(--gap) * ${cell.dataset.x - 1})`;
                        cell.style.zIndex = 1000 - (cell.dataset.x - 1) * 10 - (cell.dataset.y - 1);

                        const positioner = document.createElement('div');
                        positioner.classList.add('positioner');
                        cell.appendChild(positioner);
                        grid.appendChild(cell);
                    }
                }

                const gridCells = grid.querySelectorAll('.cell');

                gridCells.forEach((cell) => {
                    const x = cell.dataset.x;
                    const y = cell.dataset.y;
                    const gridCell = document.querySelector(`.grid .cell[data-x="${x}"][data-y="${y}"]`);
                    const cellsCell = document.querySelector(`.cells .cell[data-x="${x}"][data-y="${y}"]`);

                    if (gridCell && cellsCell) {
                        cells.push({coords: {x, y}, grid: gridCell, cell: cellsCell});
                    }
                });

                // Position cells based on grid
                cells.forEach(cell => {
                    const screenPositioner = cell.grid.querySelector('.positioner');
                    const screenPosition = screenPositioner.getBoundingClientRect();
                    const relativePosition = grid.getBoundingClientRect();

                    cell.cell.style.zIndex = 1000 - (cell.grid.dataset.x - 1) * 10 - (cell.grid.dataset.y - 1);
                    cell.cell.style.top = `${(screenPosition.top - relativePosition.top) / relativePosition.height * 100}%`;
                    cell.cell.style.left = `${(screenPosition.left - relativePosition.left) / relativePosition.width * 100}%`;
                });
            }

            function selectCube(x, y) {
                const cells = document.querySelectorAll('.cells .cell');

                cells.forEach(cell => {
                    cell.classList.add('unselected');

                    if (cell.dataset.x == x && cell.dataset.y == y) {
                        cell.classList.add('selected');
                        cell.classList.remove('unselected');
                        projectHeader.style.width = '50%';
                        projectDescription.innerText = cell.dataset.desc;
                        projectDescription.classList.remove('hidden');

                        grid.style.top = '175%';
                        cellsContainer.style.top = '175%';

                        backButton.style.transform = 'translateY(0)';
                    }
                    else if (x == 0 && y == 0) {
                        cell.classList.remove('selected');
                        cell.classList.remove('unselected');
                        projectHeader.style.width = '100%';
                        projectDescription.innerText = '';
                        projectDescription.classList.add('hidden');

                        grid.style.top = '';
                        cellsContainer.style.top = '';

                        backButton.style.transform = 'translateY(-64px)';
                    }
                });
            }

            function changeText(cell) {
                let interval = null;

                if (interval) {
                    clearTimeout(interval);
                }

                if (!projectHeader.classList.contains('hidden')) {
                    projectHeader.classList.add('hidden');

                    interval = setTimeout(() => {
                        projectHeader.innerText = cell.querySelector('img').src.split('/').pop().split('.')[0];
                        projectHeader.classList.remove('hidden');
                    }, 500);
                } else {
                    projectHeader.innerText = cell.querySelector('img').src.split('/').pop().split('.')[0];
                    projectHeader.classList.remove('hidden');
                }
            }

            // Initialize the grid and projects
            render();
            generateProjectsWithDelay();

            // Attach global selectCube function to window for onclick attribute
            window.selectCube = selectCube;

    </script>
</body>
</html>